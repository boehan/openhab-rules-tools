uid: rules_tools:threshold_alert
label: Threshold Alert
description: Triggers on a change to a member of a Group. If the new state meets a user defined criteria, an alert rule is called. When exiting an alert state, an end alert rule is called. Running this rule manually will validate the configuration.
configDescriptions:
  - name: group
    label: Triggering Group
    description: Group whose members should trigger this rule
    type: TEXT
    context: item
    filterCriteria:
      - name: type
        value: Group
    required: true
  - name: thresholdState
    label: Threshold State
    description: The state compared to to determine if the Item is alerting or not. This supports units.
    type: TEXT
    required: true
  - name: operator
    label: Comparison Operator
    description: Comparison used with Threshold State to determine if the current state is alerting.
    type: TEXT
    required: true
    options:
      - label: '= equals'
        value: '=='
      - label: '!= not equal to'
        value: '!='
      - label: '< less than'
        value: '<'
      - label: '<= less than or equal'
        value: '<='
      - label: '> greater than'
        value: '>'
      - label: '>= greater than or equal'
        value: '>='
    limitToOptions: true
  - name: invert
    label: Invert Comparison
    description: Inverts the comparison to mean the opposite (e.g. if true and operator == will mean !=)
    type: BOOLEAN
    defaultValue: false
    required: false
  - name: hysteresis
    label: Hysteresis
    description: Optional value above/below the threshold the state must achieve before it is considered to nolonger alerting.
    type: TEXT
    defaultValue: ''
    required: false
  - name: defaultAlertDelay
    label: Alert Delay
    description: How long to wait before calling the rule when the Item meets the threshold comparison, ISO8061 duration format. Can be overridden by Item metadata.
    type: TEXT
    defaultValue: ''
    required: false
  - name: defaultRemPeriod
    label: Reminder Period
    description: How long to wait between repeated calls to the threshold rule, ISO8601 duration format. Can be overridden by Item metadata.
    type: TEXT
    defaultValue: ''
    required: false
  - name: namespace
    label: Metadata Namespace
    description: The Item metadata namespace where per Item alert delay and reminder periods can be defined
    type: TEXT
    defaultValue: thresholdAlert
    required: false
  - name: alertRule
    label: Alert Rule
    description: The rule called when the Item meets the threshold criteria for at least as long as alert delay. This rule will be called repeatedly if reminder period is defined.
    type: TEXT
    context: rule
    required: true
  - name: endAlertRule
    label: End Alert Rule
    description: The rule called when the Item was previously alerted but no longer meets the threshold criteria. This is optional, will only be called once, and can be the same as the alert rule.
    type: TEXT
    context: rule
    defaultValue: ''
    required: false
  - name: dndStart
    label: Do Not Disturb Start Time
    description: Start of an optional do not disturb period. Calls to either the alert rule or the end alert rule will be suppressed during this period with the latest call made at the end of the period.
    type: TEXT
    context: time
    defaultValue: ''
    required: false
  - name: dndEnd
    label: Do Not Distrub End Time
    description: End of the do not disturb period. If this time is before the start time, the period is assumed to span midnight.
    type: TEXT
    context: time
    defaultValue: ''
    required: false
  - name: gkDelay
    label: Gatekeeper Delay
    description: Sometimes a delay is needed between calls to the rules to avoid multithreaded exceptions. The delay is in milliseconds.
    type: DECIMAL
    defaultValue: 0
    required: false
  - name: rateLimit
    label: Rate Limit
    description: Only allow the alert rule to be called this often. Events that occur before that time are dropped. Use ISO8601 duration formatting. If used with a Gatekeeper Delay it should be significantly longer.
    type: TEST
    defaultValue: ''
    required: false
triggers:
  - id: "2"
    configuration:
      groupName: "{{group}}"
    type: core.GroupStateChangeTrigger
conditions: []
actions:
  - inputs: {}
    id: "1"
    configuration:
      type: application/javascript
      script: >-
        var {helpers, loopingTimer, gatekeeper, timeUtils, rateLimit} =
        require('openhab_rules_tools');

        var {DecimalType, QuantityType, PercentType} = require('@runtime');


        console.loggerName = 'org.openhab.automation.rules_tools.Threshold Alert.'+ruleUID;

        //osgi.getService('org.apache.karaf.log.core.LogService').setLevel(console.loggerName, 'DEBUG');


        helpers.validateLibraries('4.1.0', '2.0.1');


        console.debug('Starting threshold alert');


        // Properties

        var group = '{{group}}';

        var thresholdStr = '{{thresholdState}}';

        var operator = '{{operator}}';

        var comparison = (currState, threshold) => { return currState {{operator}} threshold; };

        var invert = {{invert}};

        var defaultAlertDelay = '{{defaultAlertDelay}}';

        var defaultRemPeriod = '{{defaultRemPeriod}}';

        var namespace = '{{namespace}}';

        var alertRuleUID = '{{alertRule}}';

        var endAlertUID = '{{endAlertRule}}';

        var dndStart = '{{dndStart}}';

        var dndEnd = '{{dndEnd}}';

        var GK_DELAY = {{gkDelay}};

        var hystRange = '{{hysteresis}}';

        var rateLimitPeriod = '{{rateLimit}}';

        // holds an Object containing the alertTimer, alertOverTimer, and alerted flag

        var timers = cache.private.get('timers', () => { return {}; });


        // ~~~~~~~~~~~Functions

        /**
         * Converts an Item's state to a value we can compare in this rule.
         *
         * @param {State|string} an Item's state
         * @return {String|float|Quantity} the state converted to a usable type
         */
        var stateToValue = (state) => {
          if(typeof state === 'string') {
            console.debug('state is a string: ' + state);
            if(state.includes(' ')) {
              try {
                console.debug('state is a Quantity: ' + state);
                return Quantity(state)
              } catch(e) {
                // do nothing, leave it as a String
                console.debug('Not a Quantity but has a space, leaving as a string: ' + state);
                return state;
              }
            }
            else if(!isNaN(state)) {
              console.debug('state is a number: ' + state)
              return Number.parseFloat(state);
            }
            console.debug('Leaving state as a string');
            return state;
          }
          else if(state instanceof DecimalType || state instanceof PercentType) {
            console.debug('state is a DecimalType or PercentType: ' + state);
            return state.floatValue();
          }
          else if(state instanceof QuantityType) {
            console.debug('state is a QuantityType, converting to Quantity: ' + state);
            return Quantity(state);
          }
          else {
            console.debug('Not numeric, leaving as a string: ' + state);
            return state.toString();
          }
        }


        /**
         * Determines if the Item is in an alerting state based on the configured comparison.apply
         *
         * @param {string|float|Quantity} current state of the Item
         * @param {string|float|Quantity} threshold state to compare the current state to
         * @return {boolean} true if current is an alerting state
         */
        var isAlertingState = (currState, threshold) => {
          let calc = currState + ' ' + operator + ' ' + threshold;
          if(invert) calc = '!(' + calc + ')';
          console.debug('Checking if we are in the alerting state: ' + calc);

          let rval = false;

          // Quantities
          if(currState.unit !== undefined && threshold.unit !== undefined) {
            console.debug(currState + ' and ' + threshold + ' are both Quantities, using a Quantity comparison.');
            try {
              switch(operator) {
                case '==':
                  rval = currState.equal(threshold);
                  break;
                case '!=':
                  rval = !currState.equals(threshold);
                  break;
                case '<' :
                  rval = currState.lessThan(threshold);
                  break;
                case '<=':
                  rval = currState.lessThanOrEqual(threshold);
                  break;
                case '>' :
                  rval = currState.greaterThan(threshold);
                  break;
                case '>=':
                  rval = currState.greaterThanOrEqual(threshold);
                  break;
              }
            }
            catch(e) {
              console.debug('Cannot compare ' + currState + ' to alert state ' + threshold + ', alert state is incompatible, reverting to string comparison');
              return comparison(currState.toString(), threshold.toString());
            }
          }

          // Numbers
          else if(!isNaN(currState) && !isNaN(threshold)) {
            console.debug(currState + ' and ' + threshold + ' are both numbers, using a numerical comparison');
            rval = comparison(currState, threshold);
          }

          // Strings
          else {
            console.debug('One or both of ' + currState + ' or ' + threshold + ' are not numbers or Quantities, using a string comparison');
            rval = comparison(''+currState, ''+threshold);
          }

          return (invert) ? !rval : rval;
        }


        /**
         * Checks the proposed alerting time and adjusts it to occur at the end of the DND
         * if the proposed time falls in the DND time.
         *
         * @param {anything supported by time.toZDT()} timeout proposed time to send the alert
         * @param {String} dndStart time the DND starts
         * @param {String} dndEnd time the DND ends
         * @return {time.ZonedDateTime} adjusted time to send the alert
         */
        var generateAlertTime = (timeout, dndStart, dndEnd) => {
          if(!timeout) return null;

          let rval = time.toZDT(timeout);
          let start = time.toZDT(dndStart);
          let end = time.toZDT(dndEnd);
          if(rval.isBetweenTimes(dndStart, dndEnd)) {
            console.debug('Alert is scheduled during do not distrub time, moving to ' + dndEnd);
            rval = dndEnd;
            if(time.toZDT(rval).isBefore(time.toZDT())) {
              rval = timeUtils.toTomorrow(dndEnd);
            }
          }
          return rval;
        }


        /**
         * Calls the rule with the alert info, using the gatekeeper to prevent overloading the
         * rule. The rule is called to inforce conditions.
         *
         * @param {string} ruleID UID of the rule to call
         * @param {string} alertItem name of the Item
         * @param {State} current state of the Item
         * @param {boolean} indicates if the Item is alerting or not
         */
        var callRule = (ruleID, alertItem, state, isAlerting) => {
          console.debug('Calling ' + ruleID + ' with alertItem=' + alertItem + ', alertState=' + state + ', isAlerting=' + isAlerting);
          var rl = cache.private.get('rl', () => new rateLimit.RateLimit());

          const throttle = () => {
            var gk = cache.private.get('gatekeeper', () => new gatekeeper.Gatekeeper());
            gk.addCommand(GK_DELAY, () => {
              try {
                const allAlerting = items[group].members.filter(item => isAlertingState(stateToValue(item.state), stateToValue(thresholdStr)));
                const alertingNames = allAlerting.map(item => item.label);
                const nullItems = items[group].members.filter(item => item.state == 'NULL' || item.state == 'UNDEF');
                const nullItemNames = nullItems.map(item => item.label);
                rules.runRule(ruleID, {'alertItem':        alertItem,
                                       'alertState':       ''+state,
                                       'isAlerting':       isAlerting,
                                       'threshItems':      allAlerting,
                                       'threshItemLabels': alertingNames,
                                       'nullItems':        nullItems,
                                       'nullItemLabels':   nullItemNames}, true);
              } catch(e) {
                console.error('Error running rule ' + ruleID + '\n' + e);
              }
            });
          }
          // Only rate limit the alert, always make the end alert call
          (isAlerting && rateLimitPeriod !== '') ? rl.run(throttle, rateLimitPeriod) : throttle();
        }


        /**
         * Creates the function that gets called by the loopingTimer for a given Item. The generated
         * function returns how long to wait for the next call (adjusted for DND) or null when it's
         * time to exit.
         *
         * @param {string} name Item we are alerting on
         * @param {string} dndStart string representation of the start of the DND period, '' if there isn't one
         * @param {string} dndEnd string representaiton of the end of the DND period, '' if there isn't one
         * @param {Object} Object containing alertTimer, endAlertTimer, alerted, alertState
         * @return {function} function that takes no arguments called by the looping timer
         */
        var sendAlertGenerator = (name, dndStart, dndEnd, record) => {
          return () => {
            const item = items[name];
            const currState = stateToValue(items[name].rawState);
            const threshold = stateToValue(thresholdStr);
            const metadata = item.getMetadata()[namespace];
            const remPeriod = (metadata && metadata.configuration['remPeriod']) ? metadata.configuration['remPeriod'] : defaultRemPeriod;

            // We can still get Multithreaded exceptions when calling another rule, this should reduce the occurance of that
            console.debug('Alert timer expired for ' + name + ' with dnd between ' + dndStart + ' and ' + dndEnd);
            let repeatTime = generateAlertTime(remPeriod, dndStart, dndEnd); // returns null if remPeriod is '', which cancels the loop

            // Call alert rule if still alerting
            if(isAlertingState(currState, threshold)) {
              console.debug(name + ' is still in an alerting state.');
              callRule(alertRuleUID, name, currState, true);
              if(!record.alerted) record.alertState = currState;
              record.alerted = true;
              if(repeatTime === null) record.alertTimer = null; // clean up if no longer looping
              console.debug('Waiting until ' + repeatTime + ' to send reminder');
              return repeatTime;
            }
            // no longer alerting, cancel the repeat, send an alert if configured
            else {
              console.debug(name + ' is no longer in an alerting state but timer was not cancelled, this should not happen');
              record.alertTimer = null;
              return null;
            }
          }
        }


        /**
         * Called when the Item event indicates that it's in an alerting state. If there isn't
         * already a looping timer running, create one to initially run at alertTime (adjusted
         * for DND) and repeat according to remPeriod. If dndStart is after dndEnd, the DND is
         * assumed to span midnight.
         *
         * @param {string} name of the Item that generated the event
         * @param {State|String} state state of the Item that generated the event
         * @param {Object} record contains alertTimer, endAlertTimer, and alerted flag
         */
        var alerting = (name, state, record) => {
          console.debug(name + ' is in the alert state of ' + state);

          // Cancel the endAlertTimer if there is one
          if(record.endAlertTimer !== null) {
            console.debug('Cancelling endAlertTimer for ' + name);
            record.endAlertTimer.cancel();
            record.endAlertTimer = null;
          }

          // Set a timer for how long the Item needs to be in the alerting state before alerting.
          // If one is already set, ignore it
          if(record.alertTimer === null) {
            const item = items[name];
            const metadata = item.getMetadata()[namespace];
            const alertDelay = (metadata && metadata.configuration['alertDelay']) ? metadata.configuration['alertDelay'] : defaultAlertDelay;
            let timeout = generateAlertTime(alertDelay, dndStart, dndEnd, record);
            if(timeout === null) timeout = 'PT0S'; // run now
            console.debug('Creating looping alert timer for ' + name + ' at ' + timeout);
            record.alertTimer = new loopingTimer.LoopingTimer();
            record.alertTimer.loop(sendAlertGenerator(name, dndStart, dndEnd, record), timeout);
          }
          else {
            console.debug(name + ' already has an alert timer, ignoring event.');
          }
        }


        /**
         * Applies the hysteresis and returns true if the curr value is different enough from the
         * alert value or if the calculation cannot be done because the three arguments are not
         * compatible.
         * @param {string|float|Quantity} curr current state
         * @param {string|float|Quantity} alert the state that was alerted
         * @param {string|float|hyst} hyst the hysteresis range
         * @return {boolean} true if curr is different from alert by hyst or more, or if the arguments are incompatable.
         */
        var applyHyst = (curr, alert, hyst) => {
          console.debug('Applying hysteresis with: ' + curr + ', ' + alert + ', ' + hyst);

          // Quantity
          if(curr.unit !== undefined && alert.unit && hyst.unit !== undefined) {
            try {
              const delta = (curr.lessThan(alert)) ? alert.subtract(curr) : curr.subtract(alert);
              console.debug('Applying hysteresis, delta = ' + delta + ' hystRange = ' + hyst);
              return delta.greaterThan(hyst);
            } catch(e) {
              console.error('Attempting to apply hysteresis with Quantities of incompatable units. Not applying hysteresis');
              return true;
            }
          }
          // Number
          else if(typeof curr !== 'string' && typeof alert !== 'string' && typeof hyst !== 'string') {
            const delta = Math.abs(curr - alert);
            console.debug('Applying hysteresis, delta = ' + delta + ' hystRange = ' + hyst);
            return delta > hyst;
          }
          else {
            console.debug('Not all values are compatible, skipping hysteresis');
            return true;
          }
        }

        /**
         * Called when the Item event indicates that it is not in an alerting state.
         * Clean up the record a
         * @param {string} name name of the Item that generated the event
         * @param {string|float|Quantity} state state that generated the event
         * @param {Object} record contains alertTimer, endAlertTimer, and alerted flag
         */
        var notAlerting = (name, state, record) => {
          console.debug(name + "'s new state is " + state + ' which is no longer in the alerting state, previous alerted state is ' + record.alerted);

          // Skip if we don't pass hysteresis
          if(record.alerted && !applyHyst(state, stateToValue(thresholdStr), stateToValue(hystRange))) return;

          // Cancel the alertTimer
          if(record.alertTimer !== null) {
            console.debug('Cancelling alertTimer for ' + name);
            record.alertTimer.cancel();
            record.alertTimer = null;
          }

          // Send alert if required
          if(endAlertUID && record.alerted) {
            console.debug('Sending alert that ' + name + ' is no longer in the alerting state');
            // Schedule a timer if in DND, otherwise run now
            record.endAlertTimer = new loopingTimer.LoopingTimer();
            record.endAlertTimer.loop(() => {
              console.debug('Calling end alert rule for ' + name);
              callRule(endAlertUID, name, items[name].state, false);
              record.alerted = false;
              record.alertState = null;
              record.endAlertTimer = null;
            }, generateAlertTime(time.toZDT(), dndStart, dndEnd));
          }
          else if(!endAlertUID && record.alerted) {
            console.debug('No end alert rule is configured, exiting alerting for ' + name);
            record.alerted = false;
            record.alertState = null;
          }
          else if(!record.alerted) {
            console.debug('Exiting alerting but alert was never sent, not sending alert for ' + name);
          }
          else {
            console.warn('We should not have reached this!');
          }
        }


        /**
         * Process an Item event, checking to see if it is in an alerting state and calling
         * the alerting rule with repeats if configured. If it is no longer in an alerting
         * state and an alert was sent, call the end alerting rule if configured.
         *
         * @param {string} name the name of the Item
         * @param {string|float|Quantity} state the Item's current state
         */
        var procEvent = (name, state) => {
          console.debug('Processing state ' + state + ' from ' + name);
          const timers = cache.private.get('lt', () => { return {}; });

            // Initialze the record in timers if one doesn't already exist
          if(timers[name] === undefined || timers[name].alertTimer === undefined || timers[name].endAlertTimer === undefined || timers[name].alerted === undefined) {
            console.debug('Initializing record for ' + name);
            timers[name] = {alertTimer: null, endAlertTimer: null, alerted: false };
          }
          const record = timers[name];

          if(record === undefined) {
            console.error('Record does not exist!');
            return;
          }

          // Alerting state, set up an alert timer
          if(isAlertingState(state, stateToValue(thresholdStr))) {
            alerting(name, state, record);
          }
          // Not alerting, cancel the timer and alert if configured
          else if(name in timers) {
            notAlerting(name, state, record);
          }
          // Ignore the event
          else {
            console.debug(name + ' is not in an alerting state');
          }
        }


        /**
         * Analyzes the rule properties and Items to verify that the config will work.
         */
        var init = () => {

          console.debug( 'Rule config:\n'
                       + '  Alert State - ' + thresholdStr + '\n'
                       + '  Operator - ' + operator + '\n'
                       + '  Invert Operator - ' + invert + '\n'
                       + '  Default Alert Delay - ' + defaultAlertDelay + '\n'
                       + '  Default Reminder Duration - ' + defaultRemPeriod + '\n'
                       + '  DND Start - ' + dndStart + '\n'
                       + '  DND End - ' + dndEnd + '\n'
                       + '  Alert Rule - ' + alertRuleUID + '\n'
                       + '  End Alert Rule - ' + endAlertUID + '\n'
                       + '  Alert Group - ' + group + '\n'
                       + '  Alert Items - ' + items[group].members.map(i => i.name).join(', ') + '\n'
                       + '  Gatekeeper Delay - ' + GK_DELAY + '\n'
                       + '  Rate Limit - ' + rateLimitPeriod);

          var error = false;
          var warning = false;

          // Warn if thresholdStr is empty string, there are cases where that could be OK but most of
          // the time it isn't.
          if(thresholdStr == '') {
            warning = true;
            console.info('Alert State is an empty String, is that intended?');
          }

          // Verify the operator is valid
          if(!['==', '!=', '<', '<=', '>', '>='].includes(operator)) {
            error = true;
            console.error('Invalid operator ' + operator);
          }

          // Inform that there is no default alert delay configured, there will be no pause before alerting
          if(defaultAlertDelay == '') {
            console.info('Items without ' + namespace + ' alertDelay metadata will alert immediately');
          } else {
            try{
              time.Duration.parse(defaultAlertDelay);
            } catch(e) {
              error = true;
              console.error('The default alert delay ' + defaultAlertDelay + ' is not a parsable ISO8601 duration string');
            }
          }

          // Inform that there is no default reminder period configured, there will be no repreated alerts
          if(defaultRemPeriod == '') {
            console.info('Items without ' + namespace + ' remPeriod metadata will not repeate alerts');
          } else {
            try {
              time.Duration.parse(defaultRemPeriod);
            } catch(e) {
              error = true;
              console.error('The default reminder period ' + defaultRemPeriod + ' is not a parsable ISO8601 duration string');
            }
          }

          // Inform if both of the DND times are not set
          // Error if one but not the other is defined
          // Error if either cannot be parsed into a ZDT
          if(dndStart == '' && dndEnd == '') {
            console.info('DND Start and End are empty, no DND period will be applied');
          }
          else if(dndStart == '' && dndEnd != '') {
            console.error('DND Start is defined but DND End is not.')
          }
          else if(dndStart != '' && dndEnd == '') {
            console.error('DND Start is not defined but DND End is.')
          }
          else if(dndStart != '') {
            try {
              time.toZDT(dndStart);
            } catch(e) {
              error = true;
              console.error('DND Start ' + dndStart + ' is not parsable into a time');
            }
          }
          else if(dndEnd != '') {
            try {
              time.toZDT(dndEnd);
            } catch(e) {
              error = true;
              console.error('DND End ' + dndEnd + ' is not parsable into a time');
            }
          }

          // Error is no alert rule is configured or the rule is disabled or does not exist
          if(alertRuleUID == '') {
            error = true;
            console.error('No alert rule is configured!');
          }
          try {
            if(!rules.isEnabled(alertRuleUID)) {
              error = true;
              console.error('Alert rule ' + alertRuleUID + ' is disabled');
            }
          } catch(e) {
            error = true;
            console.error('Alert rule ' + alertRuleUID + ' does not exist');
          }

          // Inform if the end alert rule is not configured
          // Error if it is configured but it is disabled or does not exist
          if(endAlertUID == '') {
            console.info('No end alert rule configured, no rule will be called when alerting ends');
          }
          else {
            try {
              if(!rules.isEnabled(endAlertUID)) {
                error = true;
                console.error('End alert rule ' + endAlertUID + ' is diabled');
              }
            } catch(e) {
              error = true;
              console.error('End alert rule ' + endAlertUID + ' does not exist');
            }
          }

          // Inform if none of the Items have namespace metadata
          const allItems = items[group].members;
          const noMetadata = allItems.filter(item => item.getMetadata()[namespace] === undefined);
          if(noMetadata.length > 0) {
            console.info('These Items do not have ' + namespace + ' metadata and will use the default alert delay and reminder duration: '
                         + noMetadata.map(i => i.name).join(', '));
          }
          // Error if alertDelay or remPeriod are not parsable durations
          allItems.filter(item => item.getMetadata()[namespace]).forEach(item => {
            const metadata = item.getMetadata()[namespace];
            const alertDelayStr = metadata.configuration['alertDelay'];
            if(alertDelayStr) {
              try {
                time.Duration.parse(alertDelayStr);
              } catch(e) {
                error = true;
                console.error('Alert delay metadata ' + alertDelayStr + ' is not a valid ISO8601 duration string');
              }
            }
            const remPeriodStr = metadata.configuration['remPeriod'];
            if(remPeriodStr) {
              try {
                time.Duration.parse(remPeriodStr);
              } catch(e) {
                error = true;
                console.error('Reminder period metadata ' + remPeriodStr + ' is not a valid ISO8601 duration string');
              }
            }

            // Warn if namespace metadata is defined but either alertDelay nor remPeriod are defined
            if((alertDelayStr === null || alertDelayStr === '' || alertDelayStr === undefined)
               && (remPeriodStr === null || remPeriodStr === '' || remPeriodStr === undefined)) {
              warning = true;
              console.warn(name + ' has ' + namespace + ' metadata but has no alertDelay or remPeriod configuration parameters');
            }
          });

          // Error if the Group has QuantityTypes but thresholdStr is not
          const quantityTypes = allItems.filter(item => item.quantityState !== null);
          if(quantityTypes.length > 0) {
            try {
              if(!thresholdStr.includes(' ')) {
                warn = true;
                console.warn(group + ' contains Quantity states by thresholdStr ' + thresholdStr + ' does not have units, comparison will revert to number or string comparison.');
              }
              Quantity(thresholdStr);
            } catch(e) {
              warning = true;
              console.warn(group + ' contains Quantity states but thresholdStr ' + thresholdStr + ' cannot be converted to a Quantity, comparison will default to a String comparsion');
            }
          }

          // Error if the Group has more than one type of Item
          const itemTypes = allItems.filter(item => item.rawItem.class.name === allItems[0].rawItem.class.name);
          if(itemTypes.length != allItems.length) {
            error = true;
            console.error(group + ' has a mix of Item types');
          }

          // Warn if there are QuantityTypes but hystRange does not have units
          if(hystRange !== '' && quantityTypes.length > 0) {
            if(!hystRange.includes(' ')) {
              warning = true;
              console.warn(group + ' has QuantityTypes but hystRange ' + hystRange + ' does not have units.');
            }
            else {
              try {
                Quantity(hystRange);
              } catch(e) {
                warning = true;
                console.warn(group + ' has QuantityTypes by hystRange ' + hystRange + ' cannot be parsed into a Quantity.');
              }
            }
          }

          if(rateLimitPeriod !== '') {
            try {
              time.Duration.parse(rateLimitPeriod);
            } catch(e) {
              error = true;
              console.error('A rate limit was provided but ' + rateLimitPeriod + ' is not a parsable ISO8601 duration string.');
            }
          }

          if(rateLimitPeriod !== '' && GK_DELAY > 0) {
            if(time.Duration.parse(rateLimitPeriod).lessThan(GK_DELAY)) {
              warning = true;
              console.warn('Both rate limit and gatekeeper delay are defined but gatekeeper delay is greater than the rate limit. The rate limit should be significantly larger.');
            }
          }

          if(error) console.error('Errors were found in the configuration, see above for details.')
          else if(warning) console.warn('Warnings were found in the configuration, see above for details. Warnings do not necessarily mean there is a problem.')
          else console.info('Threshold Alert configs check out as OK')
        }

        //~~~~~~~~~~~~~ Body

        // If triggered by anything other than an Item event, check the config

        // Otherwise process the event to see if alerting is required

        if(this.event === undefined) {
          console.info('Rule triggered without an event, checking config.');
          init();
        }

        else {
          switch(event.type) {
            case 'ItemStateEvent':
            case 'ItemStateChangedEvent':
              console.debug('Processing an Item event');
              procEvent(event.itemName, stateToValue(event.itemState));
              break;
        //    case 'ThingStatusInfoChangedEvent': ToDo //      break;
            default:
              console.info('Rule triggered without an event it can process, checking the rule config');
              cache.private.clear();
              init();
          }
        }
    type: script.ScriptAction